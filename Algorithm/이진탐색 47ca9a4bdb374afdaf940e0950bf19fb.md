# 이진탐색

### 이진탐색이란?

- 정렬되어 있는 배열에서 특정한 값을 찾아내는 알고리즘 (이진 트리 형태로 구현)

### 탐색 방법?

⭐ 찾고자 하는 값 : X

1. 배열의 중간에 위치한 임의의 값을 선택
2. 임의로 선택한 값과 찾고자 하는 값(X)를 비교.
    - 만약 X가 임의의 중간값보다 작다면, 중간값 좌측의 데이터들을 대상으로 탐색
    - 만약 X가 임의의 중간값보다 크다면, 중간값 우측의 데이터들을 대상으로 탐색
3. 위와 동일한 방법으로 찾고자 하는 값 (X)를 찾을때까지 탐색을 반복한다.

### 🔥 만약 찾고자 하는 값이 배열에 존재하지 않는다면, 종료조건으로 배열의 크기가 1이 될때까지 돌리면 될듯 !

### 탐색 예시)

sortedArr = [17, 28, 43, 67, 88, 92, 100]    🍁찾고자 하는  값 : 43

1. 임의의 중간값 = 67 을 선택
    1. 67과 43을 비교,  43은 67보다 작으므로 67 좌측에 존재한다는걸 알 수 있음
    2. 67 좌측의 데이터 [17, 28, 43]을 대상으로 탐색해야함
2. 임의의 중간값 = 28 을 선택
    1. 28과 43을 비교, 43은 28보다 크므로 28의 우측에 존재한다는걸 알 수 있음
    2. 우측의 데이터 [43] 탐색
3. 임의의 중간값 = 43 을 선택
    1. 43과 43을 비교, 두 수의 값이 같으므로 탐색 성공

### 🍁찾고자 하는  값 : 43

→ [17, 28, 43, 67, 88, 92, 100]

→ [17, 28, 43]

→ [43]

→ 탐색 완료

### 이진탐색의 시간복잡도

- 왜 n이 아니라 log2n일까?
- 처음 길이 n인 배열에서 이진탐색을 진행할 경우,

    → [17, 28, 43, 67, 88, 92, 100]

    → [17, 28, 43]

    → [43]

    위와같이 탐색할 배열의 크기가 절반씩 줄어들기 때문.

**시간복잡도 계산**

- 처음 탐색할 배열의 크기 : N
- 탐색 최악의 경우 탐색 횟수 : K
    1. 최악의 경우 K만큼 탐색을 진행한다면,

![%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2047ca9a4bdb374afdaf940e0950bf19fb/_2021-05-07__4.30.34.png](%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2047ca9a4bdb374afdaf940e0950bf19fb/_2021-05-07__4.30.34.png)

2. 이진탐색 최악의 경우 탐색할 배열의 크기가 N → 1이 될때까지 탐색

![%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2047ca9a4bdb374afdaf940e0950bf19fb/_2021-05-07__4.32.55.png](%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A1%E1%86%B7%E1%84%89%E1%85%A2%E1%86%A8%2047ca9a4bdb374afdaf940e0950bf19fb/_2021-05-07__4.32.55.png)

결과적으로 k(최악의 경우)만큼 탐색했을때 탐색횟수는 log n만큼 탐색.

👍 **따라서 이진탐색의 시간복잡도 → log n !**

### 이진탐색 구현 (python)

```python
def binarySearch(arr,target):
    leftIndex = 0  # 탐색할 배열의 시작 인덱스
    rightIndex = len(arr)-1  # 탐색할 배열의 마지막 인덱스

    # 가장 최악의 경우, 배열의 크기가 1이 되므로 leftIndex >= rightIndex 혹은 leftIndex == rightIndex가 종료조건
    while leftIndex <= rightIndex:
        middle = (leftIndex + rightIndex) // 2

        if target < arr[middle]:
            rightIndex = middle - 1
        elif target > arr[middle]:
            leftIndex = middle + 1
        else:
            return arr[middle] # or middle

    # 만약 while문이 종료된다면 탐색하는 값이 존재하지 않으므로 -1일단 return함
    return -1
```