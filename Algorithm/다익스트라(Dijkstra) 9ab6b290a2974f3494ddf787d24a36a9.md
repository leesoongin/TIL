# 다익스트라(Dijkstra)

### 다익스트라 알고리즘의 특징

- 다이나믹 프로그래밍을 이용한 대표적인 최단경로 탐색 알고리즘
- 특정 정점에서 다른 모든 정점으로의 최단경로를 탐색하는 알고리즘
- 간선간 가중치가 존재한다
    - 이때, 노드와 노드 사이의 간선들은 모두 양의 값을 가져야 한다.
- 하나의 최단 거리를 구할 때, 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다.

### 원리

1. 출발 노드 설정
2. 출발 노드를 기준으로 각 노드의 가장 작은 가중치를 저장
3. 방문하지 않은 노드 중에서 가장 가중치가 작은 노드 선택
4. 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소비용 갱신
5. 3번 4번 과정 반복

### 다익스트라 알고리즘 기본 로직 (우선순위 큐를 이용)

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__3.50.08.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__3.50.08.png)

- 최소 가중치를 저장할 리스트 (초기화 상태)

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.45.11.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.45.11.png)

1. 5번 노드 시작
2. 5번의 인접노드 2, 4번을 간선의 가중치가 작은 순서대로 방문
    - 최소 가중치를 저장한 리스트의 값과 현재 가중치를 비교 후 작은값을 가중치 리스트에 넣는다

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.49.02.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.49.02.png)

- 결과적으로 5 → 4 의 최소 가중치는 2,   5 → 2 로의 최소 가중치는 4가 저장된다

3. 위의 과정을 반복하면

- 최소 가중치가 가장 작은 4번 노드의 인접노드 2번, 3번 노드를 방문

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.53.26.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.53.26.png)

4.  3번 노드를 방문,  3 → 4로의 가중치는 2 , 따라서 3+2 - > 5가 된다. 위의 리스트값과 비교후, 리스트의 값이 최소값이므로 리스트의 값은 변하지 않는다.

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.53.26.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__4.53.26.png)

5.  2번 노드를 방문, 2의 인접노드는 1,   2 → 1 로의 가중치는 3, 따라서 3+3 → 6이되고 리스트의 값과 비교한다.   —> 리스트 값보다 작으므로 값 교체

![%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__5.00.07.png](%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1(Dijkstra)%209ab6b290a2974f3494ddf787d24a36a9/_2021-05-17__5.00.07.png)

### 파이썬 구현 (우선순위 큐 - 최소 힙)

```python
ef dijkstra2(graph,start):
    q = []
    distances = [ float('inf') for _ in range(len(graph))] # 시작노드를 제외하고 나머지는 전부 가장 큰 값으로 초기화한다.
    heapq.heappush(q,(0,start))
    distances[start] = 0 # 시작노드에서 시작노드로 가는 가중치는 0

    while q:
        # 큐에 있는 노드들 중, 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
        # heapq 라이브러라는 최소 힙 자료구조로 구현되어 있음. 그래서 값이 작을수록 우선순위가 높아 pop하면 가장 작은 가중치를 가진 노드의 정보가 나옴
        distance, current_node = heapq.heappop(q)

        if distances[current_node] < distance : #  distances의 초기값은 시작노드를 제외하고 무한대.
            continue
        for i in graph[current_node]:
            new_distance = distance + i[1] # 현재 노드에 연결된 노드로부터 인접해 있는 노드에 방문
            if new_distance < distances[i[0]]: #  (이때, 나의 가중치 + 인접노드로의 가중치 와 최소가중치 리스트의 값과 비교)
                distances[i[0]] = new_distance # 값 다시 설정
                heapq.heappush(q,(new_distance,i[0])) # 인접노드 queue에 저장

    for i in range(1, len(graph2)):
        print(i,distances[i])
    return
```